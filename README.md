# chill_kicks

Project PUDIL CHILL KICKS NI BOS

## Mengapa membuat model Dart (mis. Product) untuk JSON?

Pembuatan model Dart diperlukan karena Flutter adalah bahasa yang menjunjung tinggi type-safety dan null-safety, sehingga setiap data yang diterima dari backend perlu dipetakan ke dalam struktur yang jelas dan konsisten. Dengan model yang terdefinisi, semua field memiliki tipe pasti, seperti String, int, atau bool, sehingga saat backend mengirim data yang tidak sesuai, error bisa terdeteksi lebih awal. Selain itu, model membuat parsing JSON lebih terpusat, mudah di-maintain ketika struktur API berubah, dan mempermudah debugging. Sebaliknya, jika kita langsung menggunakan Map<String, dynamic> tanpa model, aplikasi menjadi rentan terhadap error runtime seperti key tidak ditemukan, tipe data tidak sesuai, atau nilai null yang tidak ter-handle. Pendekatan tersebut juga membuat kode sulit dibaca, tidak terdokumentasi dengan baik, dan menyulitkan pengembangan jangka panjang.

## Apa fungsi package http dan CookieRequest dalam tugas ini? Apa perbedaan perannya?

Package http berfungsi sebagai klien HTTP dasar yang dapat melakukan GET, POST, PUT, atau DELETE untuk berkomunikasi dengan server, tetapi tidak menyimpan sesi atau cookie secara otomatis. Sementara itu, CookieRequest adalah wrapper yang disediakan oleh pbp_django_auth untuk menangani autentikasi Django secara penuh—termasuk penyimpanan cookie, status login, session ID, dan pengiriman cookie secara otomatis pada setiap request berikutnya. Dengan kata lain, http cocok untuk request data biasa tanpa autentikasi, sedangkan CookieRequest digunakan ketika aplikasi membutuhkan login, mengirim session ke backend, atau menjaga akses pengguna sesuai permissions.

## Mengapa instance CookieRequest perlu dibagikan ke seluruh komponen Flutter?

Instance CookieRequest harus dibagikan ke seluruh bagian aplikasi melalui Provider karena instance inilah yang menyimpan status login pengguna, cookie otentikasi Django, serta informasi sesi yang harus tetap konsisten selama pengguna sedang login. Jika setiap halaman membuat instance baru, maka cookie hilang, pengguna dianggap logout, dan backend tidak lagi mengenali sesi tersebut. Dengan membagikan instance tunggal ke seluruh widget tree, semua request ke server dapat otomatis membawa sesi yang sama, sehingga fitur seperti “lihat produk saya”, “buat produk”, atau “logout” bisa berjalan tanpa kehilangan konteks autentikasi.

## Mengapa diperlukan konfigurasi konektivitas seperti ALLOWED_HOSTS, 10.0.2.2, CORS, SameSite, dan izin internet?

Untuk memungkinkan Flutter berkomunikasi dengan Django, beberapa konfigurasi wajib dilakukan. Penambahan 10.0.2.2 pada ALLOWED_HOSTS diperlukan karena emulator Android tidak dapat mengakses localhost secara langsung; alamat khusus ini menjadi jembatan antara emulator dan server lokal. Pengaturan CORS juga wajib agar Flutter (yang berjalan sebagai aplikasi terpisah) diizinkan mengirim permintaan ke server Django. Selain itu, konfigurasi cookie seperti SameSite=None dan Secure=True memastikan cookie dapat dikirim melalui request lintas asal (cross-site), khususnya ketika menjalankan Flutter Web. Jika konfigurasi ini salah, pengguna tidak akan bisa login, cookie tidak tersimpan, backend menolak request, atau aplikasi akan mengalami error seperti blocked-by-CORS atau unauthorized access. Pada Android, izin akses internet wajib ditambahkan karena tanpa itu aplikasi Flutter tidak bisa melakukan request sama sekali.

## Jelaskan mekanisme pengiriman data dari input pengguna hingga ditampilkan kembali di Flutter

Pengiriman data dimulai dari input yang diberikan pengguna melalui form Flutter. Setelah form tervalidasi, data dikirim menggunakan request.postJson() atau request.post() ke endpoint Django dalam format JSON. Django menerima request tersebut, memprosesnya, menyimpan data ke database, lalu mengembalikan respons JSON berisi status dan data yang baru disimpan. Flutter menerima respons tersebut, memetakannya menjadi model Dart menggunakan fromJson(), lalu menampilkan data tersebut kembali ke layar baik dalam bentuk daftar, detail item, atau snack bar notifikasi. Mekanisme ini menghasilkan siklus penuh input → backend → database → respons → parsing model → tampil di UI.

## jelaskan mekanisme autentikasi dari login, register, hingga logout

Pada proses register, Flutter mengirim username dan password ke Django yang kemudian divalidasi menggunakan UserCreationForm. Jika valid, Django membuat akun baru dan mengembalikan status sukses. Proses login dilakukan melalui CookieRequest.login(), yang mengirim kredensial ke endpoint Django /auth/login/. Jika benar, Django membuat session baru dan mengirim cookie session ke Flutter, yang kemudian disimpan oleh instance CookieRequest. Setelah login berhasil, seluruh request selanjutnya akan otomatis membawa cookie tersebut sehingga backend mengenali pengguna yang sedang login. Logout dilakukan melalui CookieRequest.logout(), yang akan memanggil endpoint Django untuk menghapus sesi, dan Flutter pun menghapus cookie yang tersimpan. Setelah itu, aplikasi menampilkan halaman login kembali.

## Jelaskan bagaimana kamu mengimplementasikan checklist secara step-by-step

Implementasi dilakukan secara bertahap dimulai dari pembuatan model Django, migrasi database, dan pembuatan endpoint JSON. Kemudian saya membuat model Dart dan fungsi fromJson() agar Flutter dapat membaca data dari backend. Setelah itu, saya menambahkan koneksi antara Flutter dan Django menggunakan CookieRequest, memastikan konfigurasi CORS, ALLOWED_HOSTS, dan cookie sudah benar. Selanjutnya saya membuat halaman login dan register yang berkomunikasi dengan Django untuk autentikasi. Setelah login berhasil, saya membuat halaman utama, form produk, dan daftar produk yang mengambil data dari backend. Saya juga mengimplementasikan fitur create dengan postJson, fitur logout dari drawer, dan fitur filtering produk berdasarkan user yang sedang login. Semua langkah dilakukan dengan menyesuaikan kode, memeriksa request–response, serta menguji error secara iteratif hingga seluruh fitur berjalan dengan benar.